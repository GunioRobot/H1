<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:ivy="antlib:org.apache.ivy.ant" basedir="." name="H1" default="make-release">

    <property name="ivy.install.version" value="2.0.0"/>
    <condition property="ivy.home" value="${env.IVY_HOME}">
        <isset property="env.IVY_HOME"/>
    </condition>
    <property name="ivy.home" value="${user.home}/.ant"/>
    <property name="ivy.jar.dir" value="${ivy.home}/lib"/>
    <property name="ivy.jar.file" value="${ivy.jar.dir}/ivy.jar"/>

	<!-- Pickup properties set by hudson build server -->
	<property environment="env" />
	
	<property file="./version.properties"/>
	<property name="etc" value="./etc"/>
	<property name="security" value="${etc}/security"/>
    <property name="src" value="./src"/>
    <property name="src.java" value="${src}/java"/>
    <property name="test" value="./test"/>
    <property name="test.src" value="${test}/src"/>
	<property name="test.data" value="${test}/data"/>

	<property name="lib" value="./lib"/>
	<property name="definalizer.jar" value="${lib}/definalizer-0.1.1.jar"/>
	
    <property name="build" value="./build" />
    <property name="build.app" value="${build}/app" />
    <property name="build.test" value="${build}/test" />
    <property name="build.doc" value="${build}/doc" />
    <property name="build.jars" value="${build}/jars" />
    <property name="build.cobertura" value="${build}/cobertura"/>
    <property name="build.version.outputdir" value="${build}/version/com/talis/platform/h1" />
    <property name="doc.javadoc" value="${build.doc}/api" />
    <property name="doc.junit" value="${build.doc}/junit" />
    <property name="reports.cobertura" value="${build.doc}/reports/cobertura"/>
    <property name="reports.pmd" value="${build.doc}/reports/pmd"/>
	<property name="cobertura.xml" value="${reports.cobertura}/xml"/>
	<property name="cobertura.html" value="${reports.cobertura}/html"/>
	<property name="reports.junit" value="${build.doc}/reports/junit"/>
	
    <!-- Project Classpath -->
    <path id="project.classpath">
        <pathelement location="${build}"/>
        <pathelement location="${src}"/>
    </path>

    <!-- Test Classpath -->
    <path id="test.classpath">
    	<pathelement location="${build.test}"/>
    	<pathelement location="${build.app}"/>
        <pathelement location="${test.src}"/>
    	<pathelement location="${test.data}"/>
    </path>
	
    <!-- Cobertura classpath -->
    <path id="cobertura.classpath">
      <pathelement location="${build.cobertura}"/>
      <path refid="test.classpath"/>
    </path>

    <!-- PMD classpath -->
    <path id="pmd.classpath">
      <pathelement location="${pmd.ruleset}"/>
    </path>
	
    <!-- Clean up any temporary files used for the build process -->
    <target name="clean">
        <delete includeEmptyDirs="true" quiet="true">
            <fileset dir="${build}"/>
        </delete>
    </target>

    <!-- Initialise the variables and directories that are to be used throughout the script. -->
    <target name="init" depends="clean">
        <mkdir dir="${build}"/>
    	<mkdir dir="${build.app}"/>
        <tstamp>
             <format property="build.datetime" pattern="yyyy-MM-dd'T'HH:mm:ssZ"/>
             <format property="build.datetime.filename" pattern="yyyy_MM_dd'T'HH_mm_ss"/>
        </tstamp>
        <echo message="Fetching repository version from SVN"/>
        <exec executable="svnversion" spawn="false" dir="." outputproperty="repository.version">
            <arg line="."/>
        </exec>
        <echo message="safe.repository.version=${repository.version}" file="${build}/svn"/>
        <echo message="Escaping repository version with regex"/>
        <replaceregexp file="${build}/svn" match=":" replace="~" byline="true"/>
    </target>

    <target name="download-ivy" unless="offline">
        <mkdir dir="${ivy.jar.dir}"/>
        <!-- download Ivy from web site so that it can be used even without any special installation -->
        <get src="http://mrpotatohead.talis.local/svn-repos/3rdPartyDevelopmentTools/apache-ivy-${ivy.install.version}/build/artifact/ivy-${ivy.install.version}.jar" 
            dest="${ivy.jar.file}" usetimestamp="true" username="sxt" password=""/>
    </target>

    <target name="init-ivy" depends="download-ivy" unless="offline">
        <!-- try to load ivy here from ivy home, in case the user has not already dropped
          it into ant's lib dir (note that the latter copy will always take precedence).
          We will not fail as long as local lib dir exists (it may be empty) and
          ivy is in at least one of ant's lib dir or the local lib dir. -->
        <path id="ivy.lib.path">
            <fileset dir="${ivy.jar.dir}" includes="*.jar"/>
        </path>
        <taskdef resource="org/apache/ivy/ant/antlib.xml"
                   uri="antlib:org.apache.ivy.ant" classpathref="ivy.lib.path"/>
    </target>

    <target name="resolve-runtime" depends="init">
        <ivy:resolve file="./ivy.xml" conf="runtime" resolveId="runtime"/>
    	<ivy:cachepath pathid="resolved.runtime.classpath" resolveId="runtime" keep="true" />
    </target>

    <target name="resolve-build" depends="init">
        <ivy:resolve file="./ivy.xml" conf="build" resolveId="build"/>
    	<ivy:cachepath pathid="resolved.build.classpath" resolveId="build" keep="true" />
    </target>
	
	<target name="resolve-cobertura" depends="init">
	    <ivy:resolve file="./ivy.xml" conf="cobertura" resolveId="cobertura"/>
		<ivy:cachepath pathid="resolved.cobertura.classpath" resolveId="cobertura" keep="true" />
	</target>

    <target name="resolve-pmd" depends="init">
        <ivy:resolve file="./ivy.xml" conf="pmd" resolveId="pmd"/>
        <ivy:cachepath pathid="resolved.pmd.classpath" resolveId="pmd" keep="true" />    	
    </target>
	
	<target name="resolve-demo" depends="init">
	    <ivy:resolve file="./ivy.xml" conf="demo" resolveId="demo"/>
	    <ivy:cachepath pathid="resolved.demo.classpath" resolveId="demo" keep="true" />
	</target>
	
	<!-- Set the property that we'll use to build the version file when
	     the build is a manual one (we can tell because if this is an 
	     automated build under hudson, ${env.BUILD_NUMBER} will be set 
	     with the build number) 
	-->
	<target name="set-manual-build-label" unless="env.BUILD_NUMBER" depends="init">
	    <property file="${build}/svn"/>
	    <echo message="${safe.repository.version}"/>
	    <property name="build.label" value="${release.version} Development Build (Revision: ${repository.version}  Build Date: ${build.datetime} Build User: ${user.name} Build OS: ${os.name} ${os.version})"/>
	    <property name="build.filename.suffix" value="dev-${release.version}-${safe.repository.version}-${build.datetime.filename}-${user.name}"/>
	    <echo message="${build.filename.suffix}"/>
	</target>
	       
	<!-- Set the property that we'll use to build the version file when
	     the build is an automated one (we can tell because if this is an 
	     automated build under hudson, ${env.BUILD_NUMBER} will be set 
	     with the build number). 
	-->
	<target name="set-automated-build-label" if="env.BUILD_NUMBER" depends="init">
	    <property file="${build}/svn"/>
	    <property name="build.label" value="${release.version}.${env.BUILD_NUMBER}.${repository.version}"/>
	    <property name="build.filename.suffix" value="${release.version}.${env.BUILD_NUMBER}.${safe.repository.version}"/>
	</target>
	       
	<!-- Generate a Version.java file containing the major, minor and repository version
	     numbers. Also, include the build.label property set above to indicate build version 
	     and environment
	-->
	<target name="update-version-file" depends="set-automated-build-label, set-manual-build-label">
	     <echo message="Making version file for build"/>
	     <mkdir dir="${build.version.outputdir}"/>
	     <echo message='package com.talis.platform.h1;&#x0a;/// Do not edit - this file is generated by build.xml&#x0a;public class Version {&#x0a;  public static String revision = "${repository.version}";&#x0a;  public static String release = "${major.version}";&#x0a; public static String minor = "${minor.version}";&#x0a;  public static String identifier = "H1/${build.label}";&#x0a;}&#x0a;' 
	            file="${build.version.outputdir}/Version.java"/>
	</target>
	        
	<!-- Compile the generated version file -->
	<target name="compile-version-file" depends="update-version-file">
	     <echo message="Compiling generated version file"/>
	     <delete file="${build.app}/com/talis/platform/h1/Version.class"/>
	     <javac srcdir="${build}/version" destdir="${build.app}" optimize="on" debug="on" deprecation="on">
	          <classpath refid="project.classpath"/>
	     </javac>
	</target>

    <!-- Compile all application classes -->
    <target name="compile-app" depends="init, compile-version-file">
        <echo message="Compiling app code"/>
        <javac srcdir="${src.java}" destdir="${build.app}" optimize="on" debug="on" deprecation="on" encoding="UTF-8">
            <classpath refid="project.classpath"/>
            <classpath refid="resolved.runtime.classpath"/>
        </javac>
    </target>

    <!-- Compile all the unit tests -->
    <target name="compile-tests" depends="compile-app, resolve-build">
        <echo message="Compiling tests"/>
        <mkdir dir="${build.test}"/>
    	
    	<!--
    	<path id="print.classpath">
 	      	<path refid="test.classpath"/>
    		<path refid="resolved.build.classpath"/>
    	</path>
    	<antcall target="print-path">
    		<reference refid="print.classpath" torefid="print.path"/>
    	</antcall>
    	-->
    	
        <javac srcdir="${test.src}" destdir="${build.test}" optimize="on" debug="on" deprecation="on" encoding="UTF-8">
            <classpath refid="test.classpath"/>
            <classpath refid="resolved.build.classpath"/>
        </javac>
    </target>

	
    <!-- Pull together the test data, schema, config files etc -->
      <target name="test-setup">
        <mkdir dir="${reports.junit}"/>
      </target>
      
	  <!-- Tests that require us to use the definalizer agent to convert final classes -->
      <path id="definalized.test.classes">
          <fileset dir="${build.test}">
          </fileset>
      </path>
	
	  <!-- Tests that don't require us to use the definalizer agent -->
	  <path id="standard.test.classes">
	      <fileset dir="${build.test}">
	  	      <exclude name="**/*$*"/>
	  	  </fileset>
	  </path>
	
	  <!-- Run the unit test suite (without instrumentation) -->
      <target name="unit-tests" depends="compile-tests, test-setup">
      	<!-- Run the tests that don't require the definalizer agent-->
      	<path id="junit.run.classpath">
      		<path refid="test.classpath"/>
      	    <path refid="resolved.build.classpath"/>
      	</path>
      	<antcall target="run-unit-tests" inheritRefs="true">
      		<param name="make.junit.report" value="true"/>
      		<param name="junit.formatter" value="xml"/>
      		<param name="output.to.formatters" value="yes"/>
      		<param name="jvm.args" value="-Xms64M -Xmx128M"/>
      		<reference refid="standard.test.classes" torefid="test.classes"/>
      	</antcall>
      	
      	<!-- Run the tests that require the definalizer agent-->
      	<path id="junit.run.classpath">
      		<path refid="test.classpath"/>
      		<path refid="resolved.build.classpath"/>
      	</path>
      	<antcall target="run-unit-tests" inheritRefs="true">
      		<param name="make.junit.report" value="true"/>
      		<param name="junit.formatter" value="xml"/>
      		<param name="output.to.formatters" value="yes"/>
      		<param name="jvm.args" value="-Xms64M -Xmx256M -javaagent:${definalizer.jar}"/>
      		<reference refid="definalized.test.classes" torefid="test.classes"/>
      	</antcall>
      </target>
        
      <!-- Run the unit test suite (with instrumentation) -->
      <target name="cobertura" depends="compile-tests, test-setup, resolve-cobertura">
        <mkdir dir="${build.cobertura}"/>
        <mkdir dir="${reports.cobertura}"/>
        <taskdef classpathref="resolved.cobertura.classpath" resource="tasks.properties"/>
        <delete file="${build.cobertura}/cobertura.ser"/>
                    
        <cobertura-instrument todir="${build.cobertura}" datafile="${build.cobertura}/cobertura.ser">
        	<ignore regex="org.apache.commons.logging.*" />
        	<fileset dir="${build.app}">
        		<include name="**/*.class"/>
            </fileset>
        </cobertura-instrument>
        
      	<copy file= "${test.src}/log4j.xml" tofile="${build.cobertura}/log4j.xml" overwrite="true" />
      	
      	<path id="junit.run.classpath">
      	    <path refid="cobertura.classpath"/>
      		<path refid="resolved.cobertura.classpath"/>
      	</path>
      	
      	<antcall target="run-unit-tests" inheritRefs="true">
      	    <param name="make.junit.report" value="true"/>
      	    <param name="junit.formatter" value="xml"/>
      	    <param name="output.to.formatters" value="false"/>
      	    <param name="jvm.args" value="-Xms64M -Xmx128M -javaagent:${definalizer.jar}"/>
      	    <reference refid="definalized.test.classes" torefid="test.classes"/>
      	</antcall>
      	
      	<antcall target="run-unit-tests" inheritRefs="true">
      	   <param name="make.junit.report" value="true"/>
      	   <param name="junit.formatter" value="xml"/>
      	   <param name="output.to.formatters" value="false"/>
      	   <param name="jvm.args" value="-Xms64M -Xmx128M"/>
      	   <reference refid="standard.test.classes" torefid="test.classes"/>
      	</antcall>

        <cobertura-report format="html" datafile="${build.cobertura}/cobertura.ser" destdir="${cobertura.html}" srcdir="${src.java}"/>
        <cobertura-report format="xml" datafile="${build.cobertura}/cobertura.ser" destdir="${cobertura.xml}" srcdir="${src.java}"/>
    </target>

	<!-- Target to actually run all the unit tests -->
    <target name="run-unit-tests">
        <junit printsummary="yes" fork="yes" haltonerror="yes" 
        	   haltonfailure="yes" outputtoformatters="${output.to.formatters}">
            <sysproperty key="file.encoding" value="UTF-8" />
            <sysproperty key="log4j.configuration" value="log4j.xml" />
            <sysproperty key="net.sourceforge.cobertura.datafile" file="${build.cobertura}/cobertura.ser" />
            <jvmarg line="${jvm.args}"/>
            <classpath refid="resolved.build.classpath"/>
        	<classpath refid="junit.run.classpath"/>
            <formatter type="${junit.formatter}" usefile="${make.junit.report}"/>
            <batchtest haltonfailure="no" todir="${reports.junit}">
                <path refid="test.classes"/>            
            </batchtest>
        </junit>
    </target>
	
    <target name="jar">
        <mkdir dir="${build.jars}" />
        <!-- Build main H1 jar -->
    	<jar jarfile="${build.jars}/h1.jar">
    		<fileset dir="${build.app}">
            	<include name="**/*.class"/>
    		</fileset>
            <manifest>
                <attribute name="Main-Class" value="com.talis.platform.network.Node" />
            </manifest>
        </jar>
    </target>

    <target name="make-dist" depends="reports, jar">
        <mkdir dir="${build}/dist/lib"/>
    	<mkdir dir="${build}/dist/security"/>
        <ivy:retrieve pattern="${build}/dist/lib/[artifact]-[revision].[ext]" conf="runtime" sync="true" />
        <copy file= "${build.jars}/h1.jar" tofile="${build}/dist/lib/h1-${build.filename.suffix}.jar" overwrite="true" />
    	<copy file= "${src.java}/log4j.xml" tofile="${build}/dist/lib/log4j.xml" overwrite="true" />
    	<copy file= "${security}/.majat-jmx-server-keystore" 
    		  tofile="${build}/dist/security/.h1-jmx-server-keystore" 
    		  overwrite="true" />
    </target>
	
	<target name="make-launch-scripts" depends="make-dist, resolve-runtime">
        <copy file= "${etc}/install_h1_service.sh" tofile="${build}/dist/install_h1_service.sh" overwrite="true" />
        <copy file= "${etc}/h1-node.init.d" tofile="${build}/dist/h1-node.init.d" overwrite="true" />
        <copy file= "${etc}/h1-node.sh" tofile="${build}/dist/h1-node.sh" overwrite="true" />
        <copy file= "${etc}/h1-node-command" tofile="${build}/dist/h1-node-command" overwrite="true" />
        <copy file= "${etc}/jmxetric.xml" tofile="${build}/dist/jmxetric.xml" overwrite="true" />
      	<ivy:cachepath pathid="resolved.classpath" keep="true"/>
	    <pathconvert targetos="unix" property="launch.classpath" refid="resolved.runtime.classpath">
	      <mapper>
	        <chainedmapper>
	          <flattenmapper/>
	          <globmapper from="*.jar" to="lib/*.jar" casesensitive="no"/>
	        </chainedmapper>
	      </mapper>
	    </pathconvert>
        <replace dir="${build}/dist" token="@@CLASSPATH@@" value="${launch.classpath}"/>    
        <replace dir="${build}/dist" token="@@H1-JAR@@" value="h1-${build.filename.suffix}.jar"/>    
	</target>

    <target name="make-release" depends="make-dist, make-launch-scripts">
        <tar tarfile="${build}/dist/h1-${build.filename.suffix}.tar">
            <tarfileset dir="${build}/dist" mode="755">
                <include name="**"/>
            	<exclude name="**/monitor-app*"/>
            </tarfileset>
        </tar>
        <gzip zipfile="${build}/dist/h1-${build.filename.suffix}.tar.gz" src="${build}/dist/h1-${build.filename.suffix}.tar"/>
    </target>
	
    <!-- Run PMD against source -->
    <target name="pmd" description="Run PMD against the source code" depends="resolve-pmd">
      <taskdef name="pmd" classname="net.sourceforge.pmd.ant.PMDTask" classpathref="resolved.pmd.classpath"/>
      <mkdir dir="${reports.pmd}"/>
      <pmd targetjdk="1.6" rulesetfiles="./ruleset.xml" failOnRuleViolation="no" maxRuleViolations="10">
        <formatter type="html" toFile="${reports.pmd}/index.html"/>
        <formatter type="xml" toFile="${reports.pmd}/pmd_report.xml"/>
        <formatter type="text" toConsole="true"/>
        <fileset dir="${src.java}">
          <include name="**/*.java"/>
        </fileset>
      </pmd>
    </target>

    <!-- Reports target, just aggregates the cobertura and pmd targets -->
    <target name="reports" depends="cobertura, pmd" />	

	<target name="print-path">
   	    <pathconvert pathsep="${line.separator}|   |-- "
				property="echo.path"
		    	refid="print.classpath">
		</pathconvert>
		<echo message="|-- classpath"/>
		<echo message="|   |"/>
		<echo message="|   |-- ${echo.path}"/>
	</target>
	
</project>